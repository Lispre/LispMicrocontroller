This is a simple microcontroller that runs a compiled LISP dialect.  

Running in simulation

This has been tested with Icarus Verilog (http://iverilog.icarus.com/), although other tool flows are probably similar.  Tests can be run as follows:
  1. Compile the verilog model. This only needs to be recompiled the first time simulation is run or if the verilog sources have changed.
    
    make

  2. Compile the LISP sources.  This will produce two files: rom.hex, which has the raw program machine code and is loaded by the simulator, and program.lst, which is informational and shows details of the generated code.  For example:

    ./compile.py tests/test1.lisp

Note that any writes to register index 0 will be printed to standard out by the simulation test harness, which is how most simulation tests work.

  3. Run simulation.  The simulator will read rom.hex each time it starts.

    vvp sim.vvp


Running in hardware

This has only been tested under Quartus/Altera with the Cyclone II starter kit.  There are a couple of projects located 
under the fpga/ directory:
  - 7seg: simple program that displays numbers on the 4-digit, 7 segment display
  - game: a little arcade-style demo with animated sprites

To build:

 1. Compile the LISP sources.  These are located in the project directory, but must be compiled from the top directory.
For example, from LispMicrocontroller/

     ./compile.py fpga/game/game.lisp

rom.hex will be created in the top level LispMicrocontroller/ directory.

 2. Synthesize the design opening the program file (for example, fpga/game/game.qpf).  Note that the synthesis tools will 
read rom.hex to create the values for program ROM.  If you recompile the LISP sources (thereby changing rom.hex), the 
design must be re-synthesized.

 3. Run, using the programmer included with Quartus.


