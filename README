This is a simple microcontroller that runs a compiled LISP dialect.  

Running in simulation

This has been tested with Icarus Verilog (http://iverilog.icarus.com/), although other tool flows are probably similar.  Tests can be run as follows:
  1. Compile the verilog model. This only needs to be recompiled the first time simulation is run or if the verilog sources have changed.
    
    make

  2. Compile the LISP sources.  This will produce two files: rom.hex, which has the raw program machine code and is loaded by the simulator, and program.lst, which is informational and shows details of the generated code.  For example:

    ./compile.py tests/test1.lisp

Note that any writes to register index 0 will be printed to standard out by the simulation test harness, which is how most simulation tests work.

  3. Run simulation.  The simulator will read rom.hex each time it starts.

    vvp sim.vvp


Running in hardware

This has only been tested under Quartus/Altera with the Cyclone II starter kit.  The project file is located at altera/LispMicrocontroller.qpf.

 1. Compile the LISP sources, as above

 2. Synthesize the design.  Note that the synthesis tools will read rom.hex to create the values for program ROM.  If you recompile the LISP sources (thereby changing rom.hex), the design must be re-synthesized.

 3. Run.  Writing to register 1 will set the values of 8 of the LEDs (one bit per LED).  Registers 2-5 control the 7 segment LED display, and register 6 is an input to sample the four buttons.


